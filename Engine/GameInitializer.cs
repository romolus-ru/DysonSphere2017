// TODO разделить клиент и сервер полностью. выделить 3 вида классов - общий, например ModelPlayer ModelPlayers и каждый из них получит наследников клиент и сервер
// и добавить обработку  логина и регистрации. задействовать CurrentState (прописать там возможные пути движения команд обработки)
// TODO добавить информационное окно с кнопкой отмена - что бы показывать надписи на затемненном экране (ViewModalWindow должны такой фон тёмный делать)
// и выводить эту надпись заданным цветом бОльшим размером шрифта и вообще другим шрифтом
// TODO у клиента и сервера добавить возможность посылать данные
// допроверить логин на сервере. сделать регистрацию и логин на клиенте
// сделать затенение экрана по технологии модального окна - оно запускаться будет при включении модального режима
// доделать окно регистрации и логина. при соединении с сервером 

// и сделать полную цепочку : запуск сервера / запуск клиента / на клиенте жмём приконнектиться / с сервера приходит сообщение что приконнектились / на клиенте жмём регистрация / на клиенте жмём логин
// все события через просто кнопки. нужна работающая технология
// сделать в базе нужную таблицу. вторую таблицу тоже - там хранить результат проверен ли адрес или нет и некоторые другие свойства пользователя

// TODO текущая миниигра - карта статическая, хранится у клиента (набор из 20-30 точек) характеристики товаров (что где производится/требуется)
// дороги между точками тоже заранее сгенерированы
// в "городах" выводится что нужно доставить чтоб получить награду
// у игрока 1 грузовик. движение грузованка по траектории занимает время
// возможность купить несколько дополнительных грузовиков. потом можно купить модуль что бы грузовик сам выбирал что купить и куда отвезти
// основное - сделать запуск игры - инициализатор должен создать нужные модели и виды иобъединить их. связаться с сервером и получить данные о текущем прогрессеигрока оттуда

// для этого для сервера сделать цепочку - из сети пришел сигнал об игроке о логине/регистрации. он создаёт игрока , добавляет его к игрокам и связывает их
// для клиента - при запуске создать игрока и всё остальное (почти как и на сервере). При получении команды соединения создать соединение и связать созданное соединение с имеющимся игроком
// посмотреть, вроде в TCPMessage не нужен Player - всё равно он на клиенте и сервере разный.
// TODO добавить к Settings загрузку данных из БД. по идее может быть одинаковый для клиента и сервера
// возможно это будет переделка и замена _settings которые счас есть
// ModelPlayers для клиента содержит небольшие различия по отношению к серверу. возможно, придётся 2 разных класса делать. так же и для моделей игр и т.п. - проще разделить
// на клиенте всё равно получатель один. по идее будет достаточным если включится режим ожидания соединения и когда на сервере игрок авторизуется, будет прислан сигнал инициализации игрока
// и на клиенте доделать цепочку - клиент должен создасться и должен работать. при соединении с сервером он получает первым делом свой текущий код
// а потом или логинится или регистрируется или играет в игры без регистрации 
// TODO при закрытии и клиент и сервер должны отправлять сигнал о завершении работы. 
// Дополнительно на сервере должно быть отслеживание соединения, и если соединение неактивно то закрывать его. 
// у клиента должна быть проверка после долгого ничего не делания что сервер не закрыл соединение
// отправку сообщений через sendMSGData сделать асинхронной. скорее всего когда сообщения принимаются сделать и отправку если сообщения для отправки есть
// их напрямую соединять с ModelPlayer - у пользователя это будет 1 игрок, он будет получать данные и отправлять
// а на сервере это будет много ModelPlayer - каждый соединен со своим каналом и там получает/отправляет данные
// через ModelClient|ModelServer составляется список - пришедшие сообщения - и игрокам запускают обработку
// TODO подрихтовать оставшееся в визуальном плане. 
// TODO сделать окно регистрации. в базу всё это записывать
// TODO у пользователя должна быть кнопка синхронизировать данные с сервером - что бы содержимое таблиц переправилось с сервера на клиент (или в настройках или отладочный режим
// TODO сделать ClientState и ServerState - разные состояния, не пересекающиеся. на основе HashSet. хранится текущее состояние какой-либо части системы
// например что ждём соединения с сервером, ждём ответа от клиента. ServerState ClientState ServerPlayerState. возможно не пригодится.

// TODO настройки переделать - они должны быть трёх типов - общие, клиент и сервер. строка в базе должна быть типа тип записи, строка имя записи строка значение записи
// TODO форма ввода логина должна реагировать на нажатия на поля ввода и отменяться при нажатии вне формы
// TODO регистрация и вход пользователя
// TODO вывод окна перенести в GUIHelper
// сделать окна логина и регистрации, сделать состояние для соединения,попробовать устанавливать его
// TODO сделать модальное окно ввода логина, автономное - что бы только 2 метода туда передавалось - ok cancel
// TODO вынести некоторые элементы в визуализацию - вывод оттекстуренного прямоугольника, вывод горизонтальной полоски - что бы уголки определялись через текстуру 
// и вывод при отсутствии текстуры заменялся на линии (у клиента это почему то сейчас не работает)
// TODO узнать что с ентити и длиной строк -  надо как то проверять длину строк по разрешенности при записи в БД
// TODO разделить диалоговое модальное окно и сделать специализированное - окно ввода строки (заодно будет как пример, и на его основе сделать окно ввода логина)
// возможно разделить типы событий на отдельные классы даже, что бы они работали отдельно
// TODO от модального окна возможно лучше избавиться. ViewInput должен получить сигнал о том что он обрабатывает ввод и он подключается к нужным событиям
// если нажаты некоторые кнопки (enter, tab) или кликнуто вне области ввода - то отключается (и визуально это надо тоже показывать)
// TODO поэкспериментировать с gl.CallLists - может быть получится сделать из текстуры список и выводить его как шрифт
// TODO переделать настройки - счас "настройки" специализированы хранить только тип и код класса
// а надо сделать чтоб они хранили настройки в виде строк, и могли заполнять класс Settings нужными настройками
// TODO найти возможность подключаться к дебаггеру и просматривать сообщения от него. в том числе и записывать их.
// TODO работа с шейдерами
// TODO разделить объект по работе с БД на части. например авторизация, логирование, обработка игр
// TODO 2 режима работы с клавиатурой - обрабатывать каждое нажатие отдельно (через отдельный класс в котором хранится код нажатой кнопки) 
// TODO если комбинации кнопок должны обрабатываться отдельно то значит надо всё таки делать по другому
// или получать список нажатых кнопок с заданной периодичностью. но всё это должно быть в функционале класса input
// TODO кроме модального объекта есть ещё и перемещаемый плюс могут быть несколько вложенных.
// TODO для загрузки сервера сделать отдельный загрузчик с выводом прогресса. сделать стандартный загрузчик
// TODO сделать консоль с основными командами. хотя по идее всё должно управляться через интерфейс, так что можт и не нужно
// TODO основной цикл сервера перенести в отдельный поток в классе, который управляет этим потоком
// TODO попробовать перенести ViewDragable которая ведает перемещением в InputHelper. 
// как минимум оно должно реагировать на события отпускания кнопки и если перемещение было маленьким - запускать клик
// TODO элементы управления можно хранить в базе и сделать для них редактор, на основе движка
// TODO возможно проще будет сразу разделить работы с БД на серверную с БД и на клиентскую на файлах. А серверную ещё разделить минимум на 3 части - логин, общее управление (логи, чат и т.п.) и игровое управление
// TODO перенести перемещение в InputHelper - что бы можно было включать этот режим у любого элемента
// TODO для Visualization сделать helper который будет содержать методы расширения что бы вынести некоторые операции из визуализации, разгрузив основной класс
using Engine.Models;
using Engine.Utils;
using Engine.Visualization;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Engine
{
	/// <summary>
	/// Инициализирует игру. вид и модель
	/// </summary>
	public class GameInitializer
	{
		private const string LogTag = "GameInitializer";
		/// <summary>
		/// Инициализируем игру
		/// </summary>
		/// <param name="modelMain">Основной объект модели</param>
		/// <param name="viewMain">Основной объект вида</param>
		/// <param name="provider">Основной объект визуализации</param>
		/// <param name="logs">Логи</param>
		/// <param name="input">Устройство пользовательского ввода</param>
		public void InitGame(ModelMain modelMain, ViewManager viewMain, VisualizationProvider provider, LogSystem logs, Input input)
		{
			logs.AddLog(LogTag, "запускаем инициализацию игры");
			var model = CreateModel();
			var view = CreateView(provider);
			InitDelegates(model, view);
			InitResourcesThread(provider);
			// TODO добавить модель и вид в нужные места
			modelMain.AddModel(model);
			viewMain.AddView(view);
			logs.AddLog(LogTag, "инициализацию игры завершена");
		}

		/// <summary>
		/// Запуск потока для загрузки ресурсов. Переводим менеджера в режим ожидания и вывода загружаемых данных
		/// </summary>
		private void InitResourcesThread(VisualizationProvider provider)
		{
			// пока напрямую вызываем
			InitResources(provider);
		}

		/// <summary>
		/// Инициализируем ресурсы. запускается в отдельном потоке
		/// </summary>
		protected void InitResources(VisualizationProvider provider)
		{

		}
		/// <summary>
		/// Соединяем нужные делегаты модели и вида
		/// </summary>
		/// <param name="model"></param>
		/// <param name="view"></param>
		protected void InitDelegates(Model model, ViewComponent view)
		{
			
		}

		/// <summary>
		/// Создаём нужную модель
		/// </summary>
		/// <returns></returns>
		protected virtual Model CreateModel()
		{
			return null;
		}

		/// <summary>
		/// Создаём нужный вид
		/// </summary>
		/// <param name="provider"></param>
		/// <returns></returns>
		protected virtual ViewComponent CreateView(VisualizationProvider provider)
		{
			return null;
		}

	}
}
