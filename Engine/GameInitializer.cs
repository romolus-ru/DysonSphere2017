// у окна становки улучшений подсвечивать нужным цветом класс улучшения
// в магазине убрать код. описание улучшений улучшить - показать примерно сколько изменяется показатель
// возможно, оставить только начальные и обычные - но у них сделать сильнее параметры - до экстра
//ShipUpgradesEditWindow добавить 2 кнопки и переделать что бы можно было не выходя из окна отредактировать все корабли
//желательно так же что бы улучшения можно было продать
//ввести третий уровень заказов, что бы сделать более активным геймплей
// в финальной миссии возможно важный фактор будет чтоб игроки сняли автопилот - тогда они не будут получать штраф и выполнят заказ
// описание переделать, чтоб было более понятнее что за улучшения и исследования. поставить единицы измерения для чисел, коды убрать

// в магазине переделать подсветку

// FilteredScrollViewWindow ViewScroll сделать приватным
// для автоматических кораблей ввести признак - что если корабль прилетел по требованию игрока - он будет стоять в доке пока его не запустят
// и соответственно сделать кнопку запустить автопилот и запустить все автопилоты (отдельная кнопка появится когда корабль стоит на базе

// окно просмотра характеристик имеющихся ресурсов (возможно, они будут уменьшены до 5 максимум в каждой категории)

// до открытия  магазина игрок получает случайные обычные улучшения (15-20 улучшений)
// на самом деле первые модули будут не случайными - что бы игрок мог оснастить корабли лучшим образом на ранних стадиях игры
// в корабль можно вставить несколько модулей. у модулей могут быть ограничения на уровень игрока или на характеристики корабля
// например если корабль малотоннажный то поставить на него максимальный апгрейд для трюма не получится - нужно обязательно поставить 1 или 2 меньших улучшений трюма
// самое сложное ограничение будет у автоматического модуля - отсутствие модулей высшего класса на корабле
// т.е. корабль не получится сделать суперкораблем, автоматически выполняющим заказы - только корабли под управлением игрока смогут обладать отличными характеристиками
// (и так же будет жёсткое ограничение на количество автоматических кораблей)
// корабль за каждый вылет начисляет игроку опыт. с помощью модулей это можно увеличить
// так же у корабля с помощью модулей можно повысить скорость взлёта/посадки, скорость загрузки/разгрузки, мощность двигателей, поставить телепорт, увеличить дальность телепорта
// так же насчёт трюма - одно улучшение будет увеличивать объем трюма, другое улучшение будет увеличивать грузоподъемность корабля (и таким образом весовую характристику трюма)
// улучшения высшего класса можно будет только обменять на имеющиеся улучшения обычного класса и только с определенным временным интервалом - т.е. массово закупиться ми не получится
// количество модулей которые можно будет поставить на корабль будет ограничено уровнем игрока
// модули 3х типов (но не обязательно что у каждого модуля будет 3 типа):
// - обычный, увеличивает 1 характеристику
// - улучшенный увеличивает 1 характеристику и дополнительно ещё 1 или 2 характеристики (возможно, будет 2-3 модификации)
// - высшего класса - увеличивает 1 характеристику очень сильно

// при увеличении уровня игрока растёт и уровень заказов. за некоторые из них могут выдать 2-3 знака выполненного контракта. 
// особые знаки выполненного контракта будут выдаваться каждый 5й заказ.
// особые знаки выполненного контракта возможно будут использоваться только в магазине для покупки улучшений высшего качества

//запуск полёта корабля в автоматическом режиме
// внизу карты показывать заказы. корабли показывать вверху, на карте только выводить более подробную информацию при наведении мыши
// корабли при взлете должны соблюдать паузу - одномоментно с планеты может взлетать может только 1 корабль (скорость взлёта и апгрейд двигателей чен важны будут)
// возможность увеличивать скорость кораблей - выражается в том что они накапливают шаг (float) и делают 2 шага вместо 1
// (на данный момент такой паузы нету - нужно ввести и посмотреть как всё изменится)

// сделать консоль - просто текстовый режим с курсором и возможностью отлавливать на какой символ нажали, по идее желательно приблизительно функционал Console
// этот режим потом пригодится для имитации консольных режимов и создания сервисных программ работающих в консольном режиме с поддержкой множества цветов
// и как консоль внутриигровая тоже нужен будет

// у кораблей будет телепортация. в режиме полёта будет проверка - генерация энергии и прыжок сразу через несколько точек. 
// у корабля сделать ShipState - он будет выдавать текущее состояние и следующее состояние, целевое состояние и соотетственно контролировать состояния
// что бы можно было сказать кораблю лететь на базу и он завершил текущие действия и в нужный момент взял курс на базу. 
// для этого надо сделать классы хранения состояний и классы действий. что бы корабль при выполнении текущей задачи продолжил её выполнять пока не будет возможность перейти к новому заданию

// сейчас планета с которой забирают ресурсы - одна. возможно будет лучше если этих планет будет несколько - для каждого ресурса отдельная планета
// в этом случае можно будет сделать сырьевые разработки, когда один ресурс забирают с одной планеты на которой сейчас типа идёт разработка

// Отладка по UDP - отдельный проект, возможно текстовый (там можно экран настроить, будет не хуже winforms) запускает UDP сервер
// игра, если включена такая отладка, посылает по UDP данные. а в окне отладки их можно фильтровать и настраивать и даже сохранять

// SequenceGenerator - имя, описание, код, код согласованности (чтоб можно было заменить, фактически это главный параметр), seed, отступ от начала, длина последовательности (параметры для random) и тип последовательности (какой генератор использовался)
// RandomSequence - в этом классе описаны основные характеристики
// так же SequenceValues - сгенерированная детерминированная последовательность. в записи игрока будет храниться код последовательности и текущий итератор в последовательности
// так же нужны инструменты которые сгенерируют последовательность с заданными параметрами и сохранят её в памяти - например 
// случайная последовательность из 10 чисел в диапазоне из 100 чисел в которой все 10 чисел распределены равномерно. или в которых бОльшие числа встречаются реже
// так же нужны тестовые последовательности, для тестов, что бы точно проверять что генератор работает как часы, и если не как часы то значит надо перегенерировать последовательности
// каждый элемент последовательности должен появляться в последовательности заданное количество раз. 
// например последовательность 123 должна быть примерно такая 121321 (линейное распределение, бОльшее значение попадается меньшее количество раз). при этом могут быть пропуски значений, 
// важно что бы суммарное значение в автодиапазонах было распределено как надо (например 1-100, в последовательности всего 10 чисел, автораспределение по десяткам. значит 4-40-48-5-8-95 будет примерно правильной последовательностью
// ИЛИ в последовательности из N чисел K из них будут больше заданного значения
// это значит что при формировании награды отдельный предмет будет выдан игроку если вероятность превысит заданный порог.
// остальное будет выдано деньгами или добрано из менее ценных случайных призов до общей стоимости награды

// !! если вероятность другая, касающаяся нескольких предметов, то генерируемая последовательность должна обеспечить появление нужного диапазона с заданной вероятностью


// сделать 4 таблицы. одна будет хранить информацию о самой игре(название, описание и т.п.) 
// вторая таблица будет хранить ИД, ИДИгры, КодДоступа, Раздел, Данные раздела в виде джисона (все данные сразу, одной строкой
// для описания и настройки заказов это сейчас делается
// третья таблица - иерархия жанров и их описаний
// четвертая - игра-жанры

//if (IsDestroyed) return;// это проще. можно сделать интерфейс IDestroyed - и с его помощью обрабатывать события в классе Input GetSticked
// пока сделал так - возможно это проще. если будет часто попдаться то придётся сделать интерфейс и проверять в input
// или может быть сразу сделать этот интерфейс и проверку в sticked и по необходимости в других местах

// модели разделить на 2 вида - которые надо постоянно вызывать каждый тик и которые реагируют на внешние события 
// - тогда часть функционала View можно будет вынести в модель.

// свойства кораблей должны считаться - в корабли наверно можно будет вставлять улучшения
// отсюда следует что надо сделать 2 окна - просмотр кораблей/ просмотр деталей/ установка (перенос)деталей и второе - просмотр ачивок/достижений
// оба скролируемые
// сделать скролируемый компонент в котором будет бесконечная прокрутка и выбранный элемент должен центрироваться

// ввести ещё 2 валюты - одна для особо ценных покупок/улучшений и вторая счётчик покупок (float - некоторые покупки теряют свою ценность с уровнем и т.п.)
// эта валюта генерится раз в час, можно будет купить генератор этой валюты, но её будет мало - проще купить

// для планет сделать отдельный объект который хранит визуализационные данные
// для зданий надо сделать фабрику, которая по умолчанию создаёт здания, на основе прототипов. и необходимо что бы эти здания потом могли меняться и менять обрабатываемую информацию
// например менять скорость погрузки/разгрузки, цену, и т.п.

// сделать глобальную подсказку. что бы она выводилась выше всех
// и чтоб можно было сделать дополнительную группу элементов, которые выводятся выше всех остальных элементов
// сделать механизм для запуска действий (Checkers - посмотреть можт подойдёт, возможно надо будет доделать). 
// например при скролировании там нужен обработчик который работает не всё время, а только если было скролирование

// иногда почему то не летают - было на расстоянии 1 линии заказ/ресурс и не полетел
// сделать обнуление - при нажатии кнопки RecreatePoints обнулить все данные у модели и вьюхи
// отдельный элемент должен быть для кораблей - каждый корабль на начальном этапе это кнопка покупки. потом это кнопка возврата на базу
// если корабль на базе то появляется кнопка покупки улучшения

// нужна система ачивок. возможно, лучше её реализовать тк - будет общий элемент ачивки, он же общается с базой и т.п.
// второй элемент уже для каждой игры отдельно - создаётся куча обработчиков и они при срабатывании отправляют всё основному объекту
// и при запуске так же отправляет правила формирования (сложения, вычисления показателей ачивок
// ачивки могут быть пользовательские и серверные

// у картинок из атласа на сервере должно быть поле "source" - источник каждой отдельной картинки. если он пустой значит эту текстуру трогать нельзя

// для ачивок обязательно предусмотреть взаимозависимости - например некоторые должны появляться только при достижении определенного уровня у других учивок
// отдельно предусмотреть хранение данных для вывода графиков. ачивки хранят свои значения, графики хранят свои все промежуточные значения
// при перезапуске карты бОльшая часть данных удаляется. остаются только сжатые интересные статистические данные, 
// например когда были получены учивки, когда был достигнут предел в деньгах и т.п.

// сделать список заказов на стройки и присвоить их всем зданиям
// отдельно идут 3 мегастройки которые будут требовать много ресурсов
// событие загрузки/разгрузки корабля уже есть - надо списывать ресурсы и загружать их на корабль. в случае завершения заказа отправлять корабль на базу

// TODO на карте часть планет производят ресурсы, часть потребляют - выдают задание привезти определенное количество ресурсов, за это выдают деньги
// за деньги можно покупать ещё космических кораблей
// вверху несколько кнопок - купить ещё корабль, отозвать все корабли на ремонтную базу, купить модуль автоматизации

// каждый следующий корабль стоит дороже, но увеличивает у всех кораблей грузоподъемность (или надо как-либо увязать с количеством перевезенных ресурсов или выполненных контрактов)
// (или корабль можно купить не дорого, но он будет медленным и мало перевозить - а что бы нормальным кораблем был - надо вложиться. первый корабль изначально со всеми почти улучшениями)
// но пока наверно лучше просто покупку подороже сделать

// поставить 3 мега здания квестовых которым надо много ресурсов. если все они "построены" - сессия завершается

// сделать распределение точек - получаем точки безье и равномерно их располагаем - сейчас там между точками разное расстояние
// так же они должны располагаться очень близко друг к другу - что бы было плавное движение

// TODO переделать settings - программа для редактирования должна уметь редактировать и общие, и клиентские и серверные настройки
// состояние State должно сохраняться отдельно, это не часть настроек (во всяком случае пока)

// TODO у событий всё таки остаются пустые словари. попробовать нажать эти кнопки, можт что сломалось
// TODO сделать перемещение карты, распределение товаров, вывод информации о точке. точка должна быть не ScreenPoint а игровой точкой

// TODO добавить к GUIHelper функциональность привязки элементов к краям экрана, центрированию по области и т.п.
// например указываем область, и операцию привязки к точке. параметрами идут ViewComponents которые надо равномерно разместить у выбранной области
// объект который хранит область или сразу область, операция привязки к краю(центру), 
// опция разрешения изменения размеров (просто разместить поближе к краю или распределить равномерно), ViewComponents как параметры которые надо разместить

// TODO переделать StateClient в просто State которому передаётся при загрузке константа - часть имени. и сервер будет свои настройки там хранить, клиент в своём файле
// наверно пусть там будут все нужные на данный момент настройки - потом всё равно переделывать settings и они туда перенесутся. а state останется и будет хранить состояние системы

// сделать в базе нужную таблицу. вторую таблицу тоже - там хранить результат проверен ли адрес или нет и некоторые другие свойства пользователя

// TODO текущая миниигра - карта статическая, хранится у клиента (набор из 20-30 точек) характеристики товаров (что где производится/требуется)
// дороги между точками тоже заранее сгенерированы
// в "городах" выводится что нужно доставить чтоб получить награду
// у игрока 1 грузовик. движение грузовика по траектории занимает время
// возможность купить несколько дополнительных грузовиков. потом можно купить модуль что бы грузовик сам выбирал что купить и куда отвезти
// основное - сделать запуск игры - инициализатор должен создать нужные модели и виды и объединить их. связаться с сервером и получить данные о текущем прогрессе игрока оттуда

// TODO добавить к Settings загрузку данных из БД. по идее может быть одинаковый для клиента и сервера
// возможно это будет переделка и замена _settings которые счас есть
// TODO при закрытии и клиент и сервер должны отправлять сигнал о завершении работы. 
// Дополнительно на сервере должно быть отслеживание соединения, и если соединение неактивно то закрывать его. 
// у клиента должна быть проверка после долгого ничего не делания что сервер не закрыл соединение

// TODO подрихтовать оставшееся в визуальном плане. 
// TODO сделать окно регистрации. в базу всё это записывать
// TODO у пользователя должна быть кнопка синхронизировать данные с сервером - что бы содержимое таблиц переправилось с сервера на клиент (или в настройках или отладочный режим

// TODO настройки переделать - они должны быть трёх типов - общие, клиент и сервер. строка в базе должна быть типа тип записи, строка имя записи строка значение записи
// TODO форма ввода логина должна реагировать на нажатия на поля ввода и отменяться при нажатии вне формы
// TODO узнать что с ентити и длиной строк -  надо как то проверять длину строк по разрешенности при записи в БД

// TODO поэкспериментировать с gl.CallLists - может быть получится сделать из текстуры список и выводить его как шрифт
// TODO переделать настройки - счас "настройки" специализированы хранить только тип и код класса
// а надо сделать чтоб они хранили настройки в виде строк, и могли заполнять класс Settings нужными настройками
// TODO найти возможность подключаться к дебаггеру и просматривать сообщения от него. в том числе и записывать их.
// TODO работа с шейдерами
// TODO разделить объект по работе с БД на части. например авторизация, логирование, обработка игр

// TODO сделать консоль с основными командами. хотя по идее всё должно управляться через интерфейс, так что можт и не нужно
// TODO попробовать перенести ViewDragable которая ведает перемещением в InputHelper. 
// как минимум оно должно реагировать на события отпускания кнопки и если перемещение было маленьким - запускать клик

// TODO элементы управления можно хранить в базе и сделать для них редактор, на основе движка
// TODO возможно проще будет сразу разделить работы с БД на серверную с БД и на клиентскую на файлах. А серверную ещё разделить минимум на 3 части - логин, общее управление (логи, чат и т.п.) и игровое управление
// TODO перенести перемещение в InputHelper - что бы можно было включать этот режим у любого элемента
// TODO возможно диспетчер событий будет в самый раз - можно будет подписываться централизованно на любое событие из любого места и отправлять так же
// пока кажется что сложность прямого использования Action и пробрасывание их будет расти

// TODO рекомендуют хранить соль (длиною как хэш) вместе с паролем - присланный пароль XOR с солью и хэшируем - если совпало с тем что есть - окей
// у каждого своя соль

// сделать тесты и поместить их в coveralls.io

// TODO подумать что делать с CollectClass и его идентификатором. сейчас он int, при передаче по сети используется ushort. можно сделать переходную таблицу - оставить передаваемые классы в список рассылки и держать там не все возможные классы а только нужные
// или хватит 65 000 классов на ближайшее время

// TODO возможно стоит внедрить Jint - управление через джаваскрипт. некоторые методы можно туда вынести, особенно если они могут/должны настраиваться
// TODO изучить Steamwork.Net - апи для работы со стимом
// TODO программное формирование текстур. перерисовка их в процессе работы программы
// TODO OpenCL и cloo - вычисления через видеокарту. возможно могут пригодиться

// шрифт вынести в отдельный класс. будет минимум 2 варианта - обычный шрифт с GDI и WGL и текстурный шрифт - из-за проблем с вычислением длины текста.

// TODO определить 3й слой, 3D - первый это основной системный, второй это текущий, интерфейсный

// переименовать VisualizationProvider в Graphics

using Engine.Models;
using Engine.Utils;
using Engine.Visualization;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Engine
{
	/// <summary>
	/// Инициализирует игру. вид и модель
	/// </summary>
	public class GameInitializer
	{
		private const string LogTag = "GameInitializer";
		/// <summary>
		/// Инициализируем игру
		/// </summary>
		/// <param name="modelMain">Основной объект модели</param>
		/// <param name="viewMain">Основной объект вида</param>
		/// <param name="provider">Основной объект визуализации</param>
		/// <param name="logs">Логи</param>
		/// <param name="input">Устройство пользовательского ввода</param>
		public void InitGame(ModelMain modelMain, ViewManager viewMain, VisualizationProvider provider, LogSystem logs, Input input)
		{
			logs.AddLog(LogTag, "запускаем инициализацию игры");
			var model = CreateModel();
			var view = CreateView(provider);
			InitDelegates(model, view);
			InitResourcesThread(provider);
			// TODO добавить модель и вид в нужные места
			modelMain.AddModel(model);
			viewMain.AddView(view);
			logs.AddLog(LogTag, "инициализацию игры завершена");
		}

		/// <summary>
		/// Запуск потока для загрузки ресурсов. Переводим менеджера в режим ожидания и вывода загружаемых данных
		/// </summary>
		private void InitResourcesThread(VisualizationProvider provider)
		{
			// пока напрямую вызываем
			InitResources(provider);
		}

		/// <summary>
		/// Инициализируем ресурсы. запускается в отдельном потоке
		/// </summary>
		protected virtual void InitResources(VisualizationProvider provider){}
		/// <summary>
		/// Соединяем нужные делегаты модели и вида
		/// </summary>
		/// <param name="model"></param>
		/// <param name="view"></param>
		protected virtual void InitDelegates(Model model, ViewComponent view){	}

		/// <summary>
		/// Создаём нужную модель
		/// </summary>
		/// <returns></returns>
		protected virtual Model CreateModel()
		{
			return null;
		}

		/// <summary>
		/// Создаём нужный вид
		/// </summary>
		/// <param name="provider"></param>
		/// <returns></returns>
		protected virtual ViewComponent CreateView(VisualizationProvider provider)
		{
			return null;
		}

	}
}
